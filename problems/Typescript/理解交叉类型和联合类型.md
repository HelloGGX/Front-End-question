# 理解 TS 中 |、&

如何理解下面的代码：

```js
keyof(A|B) = (keyof A) & (keyof B)
keyof(A&B) = (keyof A) | (keyof B)
```

联合类型：对于指定了联合类型的变量，其值的类型必须只能是联合类型中包含的某一种，如果取了联合类型之外的类型值，在编译过程中会报错。
交叉类型：对于指定了交叉类型的变量，其值的类型必须包含交叉类型中的所有类型，缺少其中一个类型，就会报错

举个例子：

```ts
type A = {
  version: string;
  a: number;
};
type B = {
  version: string;
  b: string;
};
type T = A | B;
type K = keyof T;
```

类型 A 和类型 B 都是类型 T 的子类型， 根据鸭式辩型规则： 类型 A 上必须包含 T 的属性成员，类型 B 上必须包含 T 的属性成员，那么类型 T 上的属性成员只能是类型 A 和 B 的属性成员的交集。

> 鸭式辨形：类型 A 具有类型 T 的属性成员，则类型 A 是类型 T 的子类型，即类型 A 兼容类型 T，同时类型 A 可以赋值给类型 T，并且类型 A 上可以存在类型 T 上不存在的属性成员。
> 也就是说，一只动物游起来像鸭子，叫起来像鸭子，那么可以认为它就是一只鸭子。

我们改下类型 T:

```ts
type A = {
  version: string;
  a: number;
};
type B = {
  version: string;
  b: string;
};
type T = A & B;
type K = keyof T;
```

类型 T 具有类型 A 和类型 B 的所有属性成员， 因此 ts 推断出键值是 A 和 B 的属性集合。

再举个例子：

![](https://files.mdnice.com/user/23305/a05083e4-2ca5-4667-91b0-d03b695fc96c.png)

变量 t 必须定义 version\a\b 这三个属性才不会报错，它可以安全的赋值给 a 变量，因为这里 A 类型的成员属性一定能在 T 类型中找到，t 赋值给 a，表现为类型收敛，是安全的。

但是当改成 A|B，类型 A 的成员属性不一定能在类型 T 中找到， 表现为变量 t 可能没有变量 a 要的属性，是不安全的。

下面的图中的不同颜色表示类型T能访问A和B成员属性的不同可能:

![](https://files.mdnice.com/user/23305/340645ab-db58-4c5d-b3cd-a6f98c7c4ed8.png)

我们可以看到交叉类型中，类型A和B的区域都是同一个颜色，表示类型T一定能访问所有区域。因此它们的交叉类型，表现为"并"的效果。

而联合类型中，类型A和B的区域是不同颜色，他们唯一公共的颜色区域是他们属性成员的交集。这也是类型T能访问的安全区域，因此它们的联合类型，表现为"交"的效果

因此可以总结：

**1. 联合类型的类型成员由各个类型成员的属性成员的交集组成，属性成员的类型为各个成员类型的联合类型。**

**2. 交叉类型的类型成员由各个类型成员的属性成员的并集组成，属性成员的类型为各个成员类型的交叉类型**

